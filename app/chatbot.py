import os
import json
import aiohttp
import asyncio
import re
from typing import Dict, List, Any, Optional
from datetime import datetime, timedelta
import google.generativeai as genai
from collections import defaultdict
from .api_client import SportsAPIClient
from .nlp_processor import NLPProcessor

# Configuraci√≥n de Gemini
GEMINI_API_KEY = os.getenv("GEMINI_API_KEY")

if GEMINI_API_KEY:
    genai.configure(api_key=GEMINI_API_KEY)
    model = genai.GenerativeModel('models/gemini-1.5-flash')
else:
    model = None

class ConversationContextManager:
    def __init__(self):
        self.contexts = defaultdict(dict)
        
    def get_context(self, session_id):
        return self.contexts.get(session_id, {})
    
    def update_context(self, session_id, key, value):
        if session_id not in self.contexts:
            self.contexts[session_id] = {}
        self.contexts[session_id][key] = value
        
    def clear_context(self, session_id):
        if session_id in self.contexts:
            del self.contexts[session_id]

class SportsBettingChatbot:
    def __init__(self, api_base_url):
        self.api_client = SportsAPIClient(api_base_url)
        self.nlp_processor = NLPProcessor(self.api_client)
        self.context_manager = ConversationContextManager()
        
    async def process_query(self, query, session_id="default"):
        try:
            print(f"Procesando consulta: {query}")
            
            # Verificar si es confirmaci√≥n de apuesta
            if query.lower() in ['s√≠', 'si', 'confirmar', 's√≠ confirmar']:
                pending_bet = self.context_manager.get_context(session_id).get("pending_bet")
                if pending_bet:
                    return await self.confirm_bet(session_id)
            
            # Extraer entidades
            print("Extrayendo entidades...")
            entities = await self.nlp_processor.extract_entities_enhanced(query)
            print(f"Entidades extra√≠das: {entities}")
            
            # Manejar preguntas no relacionadas con deportes
            if entities.get("question_type") == "non_sports":
                return self._generate_non_sports_response(query)
            
            # Obtener datos relevantes de la API (filtrados por entidades)
            print("Obteniendo datos de la API...")
            relevant_data = await self.nlp_processor.get_relevant_data(entities)
            print(f"Datos relevantes obtenidos: {json.dumps(relevant_data, indent=2)[:1000]}...")
            
            # Si no hay datos, generar respuesta apropiada
            if (not relevant_data.get("fixtures") and 
                not relevant_data.get("odds") and
                not relevant_data.get("sports")):
                return self._generate_no_data_response(entities)
            
            # Generar respuesta
            context = self.context_manager.get_context(session_id)
            response = await self._generate_response_with_llm(query, entities, relevant_data, context)
            
            # Actualizar contexto
            self._update_context(session_id, entities, relevant_data)
            
            return response
        except Exception as e:
            print(f"Error processing query: {e}")
            import traceback
            traceback.print_exc()
            return self._generate_error_response()

    def _generate_no_data_response(self, entities):
        """Generar respuesta cuando no hay datos disponibles"""
        response = "üîç **No encontr√© informaci√≥n espec√≠fica en este momento**\n\n"
        
        if entities.get("teams"):
            teams = ", ".join(entities["teams"])
            response += f"Para los equipos: {teams}\n"
        
        if entities.get("tournaments"):
            tournaments = ", ".join(entities["tournaments"])
            response += f"En los torneos: {tournaments}\n"
        
        response += "\nüìã **Esto puede deberse a:**\n"
        response += "‚Ä¢ No hay partidos programados en este momento\n"
        response += "‚Ä¢ Los datos a√∫n no est√°n disponibles\n"
        response += "‚Ä¢ La informaci√≥n solicitada no est√° en nuestra base de datos\n\n"
        
        response += "üí° **Puedo ayudarte con:**\n"
        response += "‚Ä¢ Informaci√≥n general sobre equipos y torneos üèÜ\n"
        response += "‚Ä¢ Estrategias de apuestas deportivas üí°\n"
        response += "‚Ä¢ An√°lisis de partidos y probabilidades üìä\n\n"
        
        response += "¬øTe gustar√≠a que te ayude con algo espec√≠fico? üòä"
        
        return response

    async def process_betting_query(self, query, entities, session_id):
        """Procesar consultas relacionadas con apuestas"""
        # Extraer informaci√≥n de apuesta
        stake_match = re.search(r'(\$|‚Ç¨|¬£)?\s*(\d+)(?:\s*(d√≥lares|euros|libras))?', query)
        stake = float(stake_match.group(2)) if stake_match else None
        
        # Obtener odds relevantes
        relevant_data = await self.nlp_processor.get_relevant_data(entities)
        odds_data = relevant_data.get("odds", [])
        
        # Filtrar odds seg√∫n entidades
        filtered_odds = self._filter_odds_by_entities(odds_data, entities)
        
        if not filtered_odds and entities.get("teams"):
            # Buscar coincidencias parciales de nombres de equipos
            normalized_teams = [self.nlp_processor.normalize_team_name(team) for team in entities["teams"]]
            filtered_odds = [o for o in odds_data if any(
                team in o["home_team"].lower() or team in o["away_team"].lower() 
                for team in normalized_teams
            )]
        
        if not filtered_odds:
            return "No pude encontrar odds para los equipos o partidos mencionados."
        
        # Calcular posibles ganancias
        if stake and filtered_odds:
            selection = self._determine_bet_selection(entities, filtered_odds[0])
            potential_winnings = stake * filtered_odds[0]["odds"].get(selection, 1)
            
            response = f"üìä **An√°lisis de Apuesta**\n\n"
            response += f"‚Ä¢ **Partido:** {filtered_odds[0]['home_team']} vs {filtered_odds[0]['away_team']}\n"
            response += f"‚Ä¢ **Cuota para {selection}:** {filtered_odds[0]['odds'].get(selection, 'N/A')}\n"
            response += f"‚Ä¢ **Apuesta:** ${stake}\n"
            response += f"‚Ä¢ **Ganancia potencial:** ${potential_winnings:.2f}\n\n"
            response += "¬øTe gustar√≠a simular esta apuesta? (responde 's√≠' para confirmar)"
            
            # Guardar contexto de apuesta pendiente
            self.context_manager.update_context(session_id, "pending_bet", {
                "fixture_id": filtered_odds[0]["id"],
                "market_type": "moneyline",
                "selection": selection,
                "stake": stake,
                "potential_winnings": potential_winnings
            })
            
            return response
        
        return "Necesito saber cu√°nto quieres apostar para calcular las ganancias potenciales."
    
    async def confirm_bet(self, session_id):
        """Confirmar apuesta simulada"""
        pending_bet = self.context_manager.get_context(session_id).get("pending_bet")
        if not pending_bet:
            return "No hay ninguna apuesta pendiente para confirmar."
        
        # Simular colocaci√≥n de apuesta
        result = await self.api_client.place_bet(
            pending_bet["fixture_id"],
            pending_bet["market_type"],
            pending_bet["selection"],
            pending_bet["stake"]
        )
        
        if result and result.get("success"):
            response = "‚úÖ **Apuesta simulada confirmada**\n\n"
            response += f"‚Ä¢ **ID de apuesta:** {result.get('bet_id', 'SIM-001')}\n"
            response += f"‚Ä¢ **Monto apostado:** ${pending_bet['stake']}\n"
            response += f"‚Ä¢ **Ganancia potencial:** ${pending_bet['potential_winnings']:.2f}\n"
            response += f"‚Ä¢ **Estado:** {result.get('status', 'confirmada')}\n\n"
            response += "¬°Buena suerte! üçÄ"
        else:
            response = "‚ùå No pude procesar la apuesta. Por favor, intenta nuevamente."
        
        # Limpiar apuesta pendiente
        self.context_manager.update_context(session_id, "pending_bet", None)
        
        return response
    
    def _filter_odds_by_entities(self, odds_data, entities):
        """Filtrar odds basado en las entidades extra√≠das"""
        if not odds_data or not isinstance(odds_data, list):
            return []
        
        filtered_odds = []
        
        for odds in odds_data:
            if not isinstance(odds, dict):
                continue
                
            # Buscar nombres de equipos en diferentes campos posibles
            home_team = odds.get('home_team') or odds.get('homeTeam') or odds.get('home') or odds.get('team1') or ''
            away_team = odds.get('away_team') or odds.get('awayTeam') or odds.get('away') or odds.get('team2') or ''
            
            # Convertir a min√∫sculas para comparaci√≥n sin distinci√≥n de may√∫sculas/min√∫sculas
            home_team_lower = str(home_team).lower()
            away_team_lower = str(away_team).lower()
            
            # Verificar si coincide con los equipos de las entidades
            match_found = False
            if entities.get("teams"):
                for team in entities["teams"]:
                    team_lower = team.lower()
                    if team_lower in home_team_lower or team_lower in away_team_lower:
                        match_found = True
                        break
            
            # Si no hay equipos en las entidades, incluir todas las odds
            if not entities.get("teams") or match_found:
                filtered_odds.append(odds)
        
        return filtered_odds

    def _determine_bet_selection(self, entities, odds_data):
        """Determinar la selecci√≥n de apuesta basada en las entidades"""
        if not odds_data or not isinstance(odds_data, dict):
            return "home_win"  # Valor por defecto
        
        if not entities.get("bet_types"):
            return "home_win"  # Valor por defecto
        
        bet_type = entities["bet_types"][0].lower()
        
        if "draw" in bet_type or "empate" in bet_type:
            return "draw"
        elif any(word in bet_type for word in ["away", "visitante"]):
            return "away_win"
        else:
            return "home_win"
    
    async def _generate_response_with_llm(self, query, entities, relevant_data, context):
        # Determinar el tipo de deporte principal de la consulta
        sport_type = self._determine_sport_type(entities)
        
        prompt = f"""
        Eres un asistente de apuestas deportivas para **ChatBet**, una startup de IA que opera en WhatsApp y Telegram.
        Tu objetivo es proporcionar respuestas instant√°neas, precisas y √∫tiles, utilizando los datos que te proporciono.
        Tu tono debe ser experto, directo y amigable, enfocado en el valor.
        
        ---

        ### **Datos de la Sesi√≥n**

        **CONSULTA DEL USUARIO:** {query}

        **ENTIDADES IDENTIFICADAS:** {json.dumps(entities, ensure_ascii=False)}

        **DATOS DISPONIBLES:** {json.dumps(relevant_data, ensure_ascii=False)}

        **CONTEXTO PREVIO:** {json.dumps(context, ensure_ascii=False)}

        ---

        ### **Instrucciones Clave**

        1.  **Prioriza la concisi√≥n:** Ve al grano. Inicia la respuesta con la informaci√≥n m√°s relevante de `DATOS DISPONIBLES`. Evita saludos o frases introductorias gen√©ricas.
        2.  **Si hay datos, √∫salos:** Si `relevant_data` contiene informaci√≥n, √∫sala para responder la consulta directamente. Presenta los datos de forma clara y legible usando listas con vi√±etas (‚Ä¢) o tablas simples con texto.
        3.  **Si no hay datos, s√© proactivo pero honesto:** Si `relevant_data` est√° vac√≠o o no es √∫til, informa al usuario de manera transparente que no se encontraron partidos activos para su consulta. No inventes informaci√≥n. Luego, ofrece valor adicional:
            * Sugiere una consulta alternativa (ej. "Puedes preguntar por un equipo o torneo espec√≠fico").
            * Proporciona un consejo de apuesta general o una estad√≠stica interesante basada en conocimiento general.
        4.  **Adapta la respuesta al `question_type`:** Usa el campo `question_type` de las entidades para personalizar el enfoque:
            * **"An√°lisis y Recomendaci√≥n":** Ofrece una breve sugerencia de apuesta basada en las cuotas, explicando la l√≥gica detr√°s (ej. "la cuota de 1.5 sugiere que los Lakers son los favoritos").
            * **"Estad√≠sticas":** C√©ntrate en los datos relevantes que tengas. Si no hay datos, explica por qu√© la informaci√≥n es limitada y sugiere d√≥nde podr√≠an encontrarse.
            * **"Informaci√≥n General":** Responde de manera informativa, proporcionando los partidos y cuotas disponibles.
        5.  **Usa el contexto previo:** Si hay contexto previo, int√©gralo naturalmente en la respuesta para mantener la continuidad.
        6.  **A√±ade un recordatorio de responsabilidad:** Finaliza con un recordatorio conciso sobre el juego responsable. Ejemplo: "Recuerda: Apuesta de forma responsable".
        7.  **Mant√©n el lenguaje accesible:** Usa un equilibrio entre expertise y claridad. Evita jargon t√©cnico innecesario.

        Responde en espa√±ol.
        """
        
        try:
            response = model.generate_content(prompt)
            return response.text
        except Exception as e:
            print(f"Error con Gemini: {e}")
            return self._generate_resolutive_fallback(query, entities, relevant_data)
    
    def _determine_sport_type(self, entities):
        """Determina el tipo de deporte principal basado en las entidades"""
        if "nba" in [t.lower() for t in entities.get("tournaments", [])]:
            return "NBA/Baloncesto"
        elif any(t in ["champions league", "premier league", "liga espa√±ola"] for t in entities.get("tournaments", [])):
            return "F√∫tbol"
        elif entities.get("teams"):
            # Determinar por nombres de equipos
            nba_teams = ["lakers", "celtics", "warriors", "bulls"]
            if any(team in nba_teams for team in entities["teams"]):
                return "NBA/Baloncesto"
            else:
                return "F√∫tbol"
        else:
            return "Deportes Generales"
    
    def _generate_resolutive_fallback(self, query, entities, relevant_data):
        """Genera una respuesta resolutiva cuando Gemini no est√° disponible"""
        query_lower = query.lower()
        
        # Respuesta para an√°lisis y recomendaci√≥n
        if entities.get("question_type") == "an√°lisis y recomendaci√≥n":
            return self._generate_resolutive_analysis_response(entities)
        
        # Respuesta para estad√≠sticas
        elif entities.get("question_type") == "estad√≠sticas":
            return self._generate_resolutive_stats_response(entities)
        
        # Respuesta para informaci√≥n general
        else:
            return self._generate_resolutive_general_response(entities, query)
    
    def _generate_resolutive_analysis_response(self, entities):
        """Genera una respuesta resolutiva para an√°lisis y recomendaciones"""
        response = "üéØ **AN√ÅLISIS Y RECOMENDACI√ìN EXPERTA**\n\n"
        
        if entities.get("teams"):
            teams = " vs ".join(entities["teams"])
            response += f"**Partido Analizado:** {teams}\n\n"
        
        response += "üìä **Factores Clave Considerados:**\n"
        response += "‚Ä¢ Forma reciente de ambos equipos/jugadores\n"
        response += "‚Ä¢ Historial de enfrentamientos directos\n"
        response += "‚Ä¢ Lesiones y ausencias importantes\n"
        response += "‚Ä¢ Contexto de la competici√≥n/torneo\n"
        response += "‚Ä¢ Factor local√≠a/visitante\n"
        response += "‚Ä¢ Motivaci√≥n y estado mental\n\n"
        
        response += "üí° **Recomendaci√≥n de Apuesta Principal:**\n"
        if entities.get("bet_types"):
            main_bet = entities["bet_types"][0]
            response += f"**{main_bet.upper()}** - Esta opci√≥n ofrece el mejor valor seg√∫n el an√°lisis actual.\n\n"
        else:
            response += "**Moneyline (Ganador del Partido)** - Recomiendo analizar las cuotas del ganador directo.\n\n"
        
        response += "üé≤ **Estrategias Recomendadas:**\n"
        response += "‚Ä¢ Considera apuestas en vivo para aprovechar momentum changes\n"
        response += "‚Ä¢ Diversifica con apuestas a mercados alternativos\n"
        response += "‚Ä¢ Establece l√≠mites claros antes de apostar\n\n"
        
        response += "üìà **Pron√≥stico Experto:**\n"
        response += "Basado en el an√°lisis integral, espero un encuentro competitivo donde [equipo/jugador] "\
                   "podr√≠a tener una ligera ventaja debido a [raz√≥n espec√≠fica].\n\n"
        
        response += "‚ö†Ô∏è **Gesti√≥n de Riesgos:**\n"
        response += "‚Ä¢ Solo arriesga el 1-2% de tu bankroll por apuesta\n"
        response += "‚Ä¢ Considera esperar hasta cerca del inicio para mejores cuotas\n"
        response += "‚Ä¢ Monitorea noticias de √∫ltima hora sobre alineaciones\n\n"
        
        response += "¬øTe gustar√≠a que profundice en alg√∫n aspecto espec√≠fico o prefieres que analice otras opciones de apuesta? üèÜ"

        return response
    
    def _generate_resolutive_stats_response(self, entities):
        """Genera una respuesta resolutiva para consultas estad√≠sticas"""
        response = "üìä **AN√ÅLISIS ESTAD√çSTICO COMPLETO**\n\n"
        
        if entities.get("teams"):
            teams = ", ".join(entities["teams"])
            response += f"**Estad√≠sticas Solicitadas:** {teams}\n\n"
        
        response += "üìà **M√©tricas Clave Analizadas:**\n"
        response += "‚Ä¢ Rendimiento en los √∫ltimos 10 partidos\n"
        response += "‚Ä¢ Eficiencia ofensiva y defensiva\n"
        response += "‚Ä¢ Estad√≠sticas en casa vs fuera\n"
        response += "‚Ä¢ Tendencia de resultados recientes\n"
        response += "‚Ä¢ Comparativa con promedio de la liga\n\n"
        
        response += "üî¢ **Datos Estad√≠sticos Relevantes:**\n"
        response += "‚Ä¢ **Victorias/Derrotas:** [X]% de efectividad\n"
        response += "‚Ä¢ **Puntos/Goles Anotados:** [X] por partido (avg)\n"
        response += "‚Ä¢ **Puntos/Goles Recibidos:** [X] por partido (avg)\n"
        response += "‚Ä¢ **Diferencial:** [+X] a favor del equipo\n"
        response += "‚Ä¢ **Rendimiento en Crucial Moments:** [X]% de efectividad\n\n"
        
        response += "üìã **Tendencias Identificadas:**\n"
        response += "‚Ä¢ Tendencia [alcista/bajista/estable] en rendimiento\n"
        response += "‚Ä¢ Fortaleza particular en [aspecto espec√≠fico]\n"
        response += "‚Ä¢ Oportunidad de mejora en [√°rea espec√≠fica]\n"
        response += "‚Ä¢ Correlaci√≥n interesante entre [m√©trica A] y [m√©trica B]\n\n"
        
        response += "üí° **Aplicaci√≥n Pr√°ctica:**\n"
        response += "Estas estad√≠sticas sugieren que [conclusi√≥n accionable] para "\
                   "tus decisiones de apuestas. Recomiendo considerar [estrategia espec√≠fica].\n\n"
        
        response += "¬øNecesitas que profundice en alguna m√©trica espec√≠fica o prefieres el an√°lisis de otro aspecto? üìù"

        return response
    
    def _generate_resolutive_general_response(self, entities, query):
        """Genera una respuesta resolutiva para consultas generales"""
        response = "üèÜ **INFORMACI√ìN DEPORTIVA COMPLETA**\n\n"
        
        response += f"**Consulta:** {query}\n\n"
        
        response += "üìã **Contexto General:**\n"
        response += "Bas√°ndome en tu consulta, aqu√≠ tienes informaci√≥n completa y relevante:\n\n"
        
        if entities.get("teams"):
            teams = ", ".join(entities["teams"])
            response += f"**Equipos/Jugadores:** {teams}\n"
            response += "‚Ä¢ Historial y logros relevantes\n"
            response += "‚Ä¢ Situaci√≥n actual en competiciones\n"
            response += "‚Ä¢ Pr√≥ximos desaf√≠os y partidos\n\n"
        
        if entities.get("tournaments"):
            tournaments = ", ".join(entities["tournaments"])
            response += f"**Torneos/Competiciones:** {tournaments}\n"
            response += "‚Ä¢ Formato y estructura de la competici√≥n\n"
            response += "‚Ä¢ Equipos participantes y favoritos\n"
            response += "‚Ä¢ Fechas clave y calendario\n\n"
        
        response += "üíé **Valor A√±adido:**\n"
        response += "‚Ä¢ **Factores Clave a Considerar:** [Aspectos importantes]\n"
        response += "‚Ä¢ **Oportunidades Destacadas:** [√Åreas de inter√©s]\n"
        response += "‚Ä¢ **Perspectiva Experta:** [An√°lisis profesional]\n\n"
        
        response += "üéØ **Recomendaci√≥n Accionable:**\n"
        response += "Basado en esta informaci√≥n, te recomiendo [acci√≥n espec√≠fica] "\
                   "para maximizar tus oportunidades en apuestas relacionadas.\n\n"
        
        response += "‚ö†Ô∏è **Recordatorio Importante:**\n"
        response += "‚Ä¢ Las apuestas deben ser siempre responsables\n"
        response += "‚Ä¢ Investiga m√∫ltiples fuentes antes de decidir\n"
        response += "‚Ä¢ Establece l√≠mites claros de bankroll\n\n"
        
        response += "¬øEn qu√© otro aspecto te puedo ayudar o necesitas m√°s detalles sobre algo espec√≠fico? ü§î"

        return response
    
    def _generate_non_sports_response(self, query):
        """Genera una respuesta educada para consultas no deportivas"""
        return "¬°Hola! üëã Soy un asistente especializado exclusivamente en deportes y apuestas deportivas. üèÜ\n\n" \
               "Puedo ayudarte con:\n" \
               "‚Ä¢ An√°lisis de partidos y equipos üèÄ‚öΩ\n" \
               "‚Ä¢ Recomendaciones de apuestas informadas üí∞\n" \
               "‚Ä¢ Estad√≠sticas deportivas üìä\n" \
               "‚Ä¢ Informaci√≥n sobre torneos y competiciones üèÖ\n\n" \
               "¬øEn qu√© puedo ayudarte respecto a deportes o apuestas deportivas? üòä"
    
    def _generate_error_response(self):
        """Genera una respuesta para errores del sistema"""
        return "¬°Vaya! üîß Estoy teniendo dificultades t√©cnicas moment√°neas, pero quiero ayudarte. \n\n" \
               "Mientras resuelvo esto, te puedo orientar sobre:\n" \
               "‚Ä¢ Estrategias generales de apuestas deportivas üéØ\n" \
               "‚Ä¢ An√°lisis de equipos y torneos populares üìà\n" \
               "‚Ä¢ Conceptos clave de apuestas deportivas üí°\n\n" \
               "¬øSobre qu√© deporte o tipo de apuesta te gustar√≠a conversar? üòä"
    
    def _update_context(self, session_id, entities, relevant_data):
        if "teams" in entities and entities["teams"]:
            self.context_manager.update_context(session_id, "last_mentioned_teams", entities["teams"])
        
        if "tournaments" in entities and entities["tournaments"]:
            self.context_manager.update_context(session_id, "last_mentioned_tournament", entities["tournaments"][0])
        
        if "bet_types" in entities and entities["bet_types"]:
            self.context_manager.update_context(session_id, "preferred_bet_types", entities["bet_types"])
    
    async def is_connected(self):
        return await self.api_client.is_connected()