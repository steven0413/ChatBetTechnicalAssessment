import os
import json
import aiohttp
import asyncio
import re
from typing import Dict, List, Any, Optional
from datetime import datetime, timedelta
import google.generativeai as genai
from collections import defaultdict
from .api_client import SportsAPIClient
from .nlp_processor import NLPProcessor

# Configuraci√≥n de Gemini
GEMINI_API_KEY = os.getenv("GEMINI_API_KEY")

if GEMINI_API_KEY:
    genai.configure(api_key=GEMINI_API_KEY)
    model = genai.GenerativeModel('models/gemini-1.5-flash')
else:
    model = None

class ConversationContextManager:
    def __init__(self):
        self.contexts = defaultdict(dict)
        
    def get_context(self, session_id):
        return self.contexts.get(session_id, {})
    
    def update_context(self, session_id, key, value):
        if session_id not in self.contexts:
            self.contexts[session_id] = {}
        self.contexts[session_id][key] = value
        
    def clear_context(self, session_id):
        if session_id in self.contexts:
            del self.contexts[session_id]

class SportsBettingChatbot:
    def __init__(self, api_base_url):
        self.api_client = SportsAPIClient(api_base_url)
        self.nlp_processor = NLPProcessor(self.api_client)
        self.context_manager = ConversationContextManager()
        
    async def process_query(self, query, session_id="default"):
        try:
            print(f"Procesando consulta: {query}")
            
            # Verificar si es confirmaci√≥n de apuesta
            if query.lower() in ['s√≠', 'si', 'confirmar', 's√≠ confirmar']:
                pending_bet = self.context_manager.get_context(session_id).get("pending_bet")
                if pending_bet:
                    return await self.confirm_bet(session_id)
            
            # Extraer entidades
            print("Extrayendo entidades...")
            entities = await self.nlp_processor.extract_entities_enhanced(query)
            print(f"Entidades extra√≠das: {entities}")
            
            # Manejar preguntas no relacionadas con deportes
            if entities.get("question_type") == "non_sports":
                return self._generate_non_sports_response(query)
            
            # Obtener datos relevantes de la API (filtrados por entidades)
            relevant_data = await self.nlp_processor.get_relevant_data(entities)
            print(f"Datos relevantes obtenidos: {relevant_data}")
            
            # Generar respuesta
            context = self.context_manager.get_context(session_id)
            response = await self._generate_response_with_llm(query, entities, relevant_data, context)
            
            # Actualizar contexto
            self._update_context(session_id, entities, relevant_data)
            
            return response
        except Exception as e:
            print(f"Error processing query: {e}")
            return self._generate_error_response()
    
    async def process_betting_query(self, query, entities, session_id):
        """Procesar consultas relacionadas con apuestas"""
        # Extraer informaci√≥n de apuesta
        stake_match = re.search(r'(\$|‚Ç¨|¬£)?\s*(\d+)(?:\s*(d√≥lares|euros|libras))?', query)
        stake = float(stake_match.group(2)) if stake_match else None
        
        # Obtener odds relevantes
        relevant_data = await self.nlp_processor.get_relevant_data(entities)
        odds_data = relevant_data.get("odds", [])
        
        # Filtrar odds seg√∫n entidades
        filtered_odds = self._filter_odds_by_entities(odds_data, entities)
        
        if not filtered_odds and entities.get("teams"):
            # Intentar buscar por nombres normalizados
            normalized_teams = [self.nlp_processor.normalize_team_name(team) for team in entities["teams"]]
            filtered_odds = [o for o in odds_data if any(
                team in o["home_team"].lower() or team in o["away_team"].lower() 
                for team in normalized_teams
            )]
        
        if not filtered_odds:
            return "No pude encontrar odds para los equipos o partidos mencionados."
        
        # Calcular posibles ganancias
        if stake and filtered_odds:
            selection = self._determine_bet_selection(entities, filtered_odds[0])
            potential_winnings = stake * filtered_odds[0]["odds"].get(selection, 1)
            
            response = f"üìä **An√°lisis de Apuesta**\n\n"
            response += f"‚Ä¢ **Partido:** {filtered_odds[0]['home_team']} vs {filtered_odds[0]['away_team']}\n"
            response += f"‚Ä¢ **Cuota para {selection}:** {filtered_odds[0]['odds'].get(selection, 'N/A')}\n"
            response += f"‚Ä¢ **Apuesta:** ${stake}\n"
            response += f"‚Ä¢ **Ganancia potencial:** ${potential_winnings:.2f}\n\n"
            response += "¬øTe gustar√≠a simular esta apuesta? (responde 's√≠' para confirmar)"
            
            # Guardar contexto de apuesta pendiente
            self.context_manager.update_context(session_id, "pending_bet", {
                "fixture_id": filtered_odds[0]["id"],
                "market_type": "moneyline",
                "selection": selection,
                "stake": stake,
                "potential_winnings": potential_winnings
            })
            
            return response
        
        return "Necesito saber cu√°nto quieres apostar para calcular las ganancias potenciales."
    
    async def confirm_bet(self, session_id):
        """Confirmar apuesta simulada"""
        pending_bet = self.context_manager.get_context(session_id).get("pending_bet")
        if not pending_bet:
            return "No hay ninguna apuesta pendiente para confirmar."
        
        # Simular colocaci√≥n de apuesta
        result = await self.api_client.place_bet(
            pending_bet["fixture_id"],
            pending_bet["market_type"],
            pending_bet["selection"],
            pending_bet["stake"]
        )
        
        if result and result.get("success"):
            response = "‚úÖ **Apuesta simulada confirmada**\n\n"
            response += f"‚Ä¢ **ID de apuesta:** {result.get('bet_id', 'SIM-001')}\n"
            response += f"‚Ä¢ **Monto apostado:** ${pending_bet['stake']}\n"
            response += f"‚Ä¢ **Ganancia potencial:** ${pending_bet['potential_winnings']:.2f}\n"
            response += f"‚Ä¢ **Estado:** {result.get('status', 'confirmada')}\n\n"
            response += "¬°Buena suerte! üçÄ"
        else:
            response = "‚ùå No pude procesar la apuesta. Por favor, intenta nuevamente."
        
        # Limpiar apuesta pendiente
        self.context_manager.update_context(session_id, "pending_bet", None)
        
        return response
    
    def _filter_odds_by_entities(self, odds_data, entities):
        """Filtrar odds basado en las entidades extra√≠das"""
        if not odds_data or not isinstance(odds_data, list):
            return []
    
        filtered_odds = odds_data
    
        # Filtrar por equipos
        if entities.get("teams"):
            filtered_odds = [
                o for o in filtered_odds 
                if o and isinstance(o, dict) and 
                any(team in o.get("home_team", "").lower() or team in o.get("away_team", "").lower() 
                for team in entities["teams"])
        ]
    
        # Filtrar por torneos
        if entities.get("tournaments"):
            filtered_odds = [
            o for o in filtered_odds 
            if o and isinstance(o, dict) and 
            any(tournament in o.get("tournament", "").lower() for tournament in entities["tournaments"])
        ]
    
        # Filtrar por fechas
        if entities.get("dates"):
            filtered_odds = [
            o for o in filtered_odds 
            if o and isinstance(o, dict) and 
            any(date in o.get("date", "") for date in entities["dates"])
        ]
    
        return filtered_odds

    def _determine_bet_selection(self, entities, odds_data):
        """Determinar la selecci√≥n de apuesta basada en las entidades"""
        if not odds_data or not isinstance(odds_data, dict):
            return "home_win"  # Valor por defecto
    
        if not entities.get("bet_types"):
            return "home_win"  # Valor por defecto
    
        bet_type = entities["bet_types"][0].lower()
    
        if "draw" in bet_type or "empate" in bet_type:
            return "draw"
        elif any(word in bet_type for word in ["away", "visitante"]):
            return "away_win"
        else:
            return "home_win"
    
    async def _generate_response_with_llm(self, query, entities, relevant_data, context):
        # Determinar el tipo de deporte principal de la consulta
        sport_type = self._determine_sport_type(entities)
        
        prompt = f"""
        Eres un asistente de apuestas deportivas experto, resolutivo, pedag√≥gico y profesional. Tu objetivo es proporcionar respuestas completas, 
        √∫tiles y accionables para cualquier consulta relacionada con deportes y apuestas, incluso cuando la informaci√≥n 
        espec√≠fica no est√© disponible en tu base de datos actual.

        CONSULTA DEL USUARIO: {query}

        DEPORTE PRINCIPAL: {sport_type}

        ENTIDADES IDENTIFICADAS: {json.dumps(entities, ensure_ascii=False)}

        DATOS DISPONIBLES: {json.dumps(relevant_data, ensure_ascii=False)}

        CONTEXTO PREVIO: {json.dumps(context, ensure_ascii=False)}

        DIRECTRICES ESTRICTAS:
        1. **S√â 100% RESOLUTIVO**: Nunca digas "no tengo informaci√≥n" o "no puedo ayudarte". Siempre proporciona valor.
        2. **USA INFORMACI√ìN CONTEXTUAL**: Si no tienes datos espec√≠ficos, usa conocimiento general del deporte.
        3. **PROPORCIONA RECOMENDACIONES ACCIONABLES**: Ofrece consejos concretos que el usuario pueda seguir.
        4. **MANT√âN CONVERSACI√ìN FLUIDA**: S√© natural, amigable y conversacional.
        5. **EDUCA AL USUARIO**: Explica conceptos de apuestas cuando sea relevante.
        6. **GENERA CONFIANZA**: Usa lenguaje experto pero accesible.

        ESTRUCTURA DE RESPUESTA IDEAL:
        - Saludo amigable y reconocimiento de la consulta
        - An√°lisis/respuesta principal con informaci√≥n valiosa
        - Recomendaciones espec√≠ficas y accionables
        - Explicaci√≥n educativa cuando sea necesario
        - Pr√≥ximos pasos o preguntas de seguimiento
        - Recordatorio de apuestas responsables

        Responde en espa√±ol con un estilo conversacional pero informativo.
        """
        
        try:
            response = model.generate_content(prompt)
            return response.text
        except Exception as e:
            print(f"Error con Gemini: {e}")
            return self._generate_resolutive_fallback(query, entities, relevant_data)
    
    def _determine_sport_type(self, entities):
        """Determina el tipo de deporte principal basado en las entidades"""
        if "nba" in [t.lower() for t in entities.get("tournaments", [])]:
            return "NBA/Baloncesto"
        elif any(t in ["champions league", "premier league", "liga espa√±ola"] for t in entities.get("tournaments", [])):
            return "F√∫tbol"
        elif entities.get("teams"):
            # Determinar por nombres de equipos
            nba_teams = ["lakers", "celtics", "warriors", "bulls"]
            if any(team in nba_teams for team in entities["teams"]):
                return "NBA/Baloncesto"
            else:
                return "F√∫tbol"
        else:
            return "Deportes Generales"
    
    def _generate_resolutive_fallback(self, query, entities, relevant_data):
        """Genera una respuesta resolutiva cuando Gemini no est√° disponible"""
        query_lower = query.lower()
        
        # Respuesta para an√°lisis y recomendaci√≥n
        if entities.get("question_type") == "an√°lisis y recomendaci√≥n":
            return self._generate_resolutive_analysis_response(entities)
        
        # Respuesta para estad√≠sticas
        elif entities.get("question_type") == "estad√≠sticas":
            return self._generate_resolutive_stats_response(entities)
        
        # Respuesta para informaci√≥n general
        else:
            return self._generate_resolutive_general_response(entities, query)
    
    def _generate_resolutive_analysis_response(self, entities):
        """Genera una respuesta resolutiva para an√°lisis y recomendaciones"""
        response = "üéØ **AN√ÅLISIS Y RECOMENDACI√ìN EXPERTA**\n\n"
        
        if entities.get("teams"):
            teams = " vs ".join(entities["teams"])
            response += f"**Partido Analizado:** {teams}\n\n"
        
        response += "üìä **Factores Clave Considerados:**\n"
        response += "‚Ä¢ Forma reciente de ambos equipos/jugadores\n"
        response += "‚Ä¢ Historial de enfrentamientos directos\n"
        response += "‚Ä¢ Lesiones y ausencias importantes\n"
        response += "‚Ä¢ Contexto de la competici√≥n/torneo\n"
        response += "‚Ä¢ Factor local√≠a/visitante\n"
        response += "‚Ä¢ Motivaci√≥n y estado mental\n\n"
        
        response += "üí° **Recomendaci√≥n de Apuesta Principal:**\n"
        if entities.get("bet_types"):
            main_bet = entities["bet_types"][0]
            response += f"**{main_bet.upper()}** - Esta opci√≥n ofrece el mejor valor seg√∫n el an√°lisis actual.\n\n"
        else:
            response += "**Moneyline (Ganador del Partido)** - Recomiendo analizar las cuotas del ganador directo.\n\n"
        
        response += "üé≤ **Estrategias Recomendadas:**\n"
        response += "‚Ä¢ Considera apuestas en vivo para aprovechar momentum changes\n"
        response += "‚Ä¢ Diversifica con apuestas a mercados alternativos\n"
        response += "‚Ä¢ Establece l√≠mites claros antes de apostar\n\n"
        
        response += "üìà **Pron√≥stico Experto:**\n"
        response += "Basado en el an√°lisis integral, espero un encuentro competitivo donde [equipo/jugador] "\
                   "podr√≠a tener una ligera ventaja debido a [raz√≥n espec√≠fica].\n\n"
        
        response += "‚ö†Ô∏è **Gesti√≥n de Riesgos:**\n"
        response += "‚Ä¢ Solo arriesga el 1-2% de tu bankroll por apuesta\n"
        response += "‚Ä¢ Considera esperar hasta cerca del inicio para mejores cuotas\n"
        response += "‚Ä¢ Monitorea noticias de √∫ltima hora sobre alineaciones\n\n"
        
        response += "¬øTe gustar√≠a que profundice en alg√∫n aspecto espec√≠fico o prefieres que analice otras opciones de apuesta? üèÜ"

        return response
    
    def _generate_resolutive_stats_response(self, entities):
        """Genera una respuesta resolutiva para consultas estad√≠sticas"""
        response = "üìä **AN√ÅLISIS ESTAD√çSTICO COMPLETO**\n\n"
        
        if entities.get("teams"):
            teams = ", ".join(entities["teams"])
            response += f"**Estad√≠sticas Solicitadas:** {teams}\n\n"
        
        response += "üìà **M√©tricas Clave Analizadas:**\n"
        response += "‚Ä¢ Rendimiento en los √∫ltimos 10 partidos\n"
        response += "‚Ä¢ Eficiencia ofensiva y defensiva\n"
        response += "‚Ä¢ Estad√≠sticas en casa vs fuera\n"
        response += "‚Ä¢ Tendencia de resultados recientes\n"
        response += "‚Ä¢ Comparativa con promedio de la liga\n\n"
        
        response += "üî¢ **Datos Estad√≠sticos Relevantes:**\n"
        response += "‚Ä¢ **Victorias/Derrotas:** [X]% de efectividad\n"
        response += "‚Ä¢ **Puntos/Goles Anotados:** [X] por partido (avg)\n"
        response += "‚Ä¢ **Puntos/Goles Recibidos:** [X] por partido (avg)\n"
        response += "‚Ä¢ **Diferencial:** [+X] a favor del equipo\n"
        response += "‚Ä¢ **Rendimiento en Crucial Moments:** [X]% de efectividad\n\n"
        
        response += "üìã **Tendencias Identificadas:**\n"
        response += "‚Ä¢ Tendencia [alcista/bajista/estable] en rendimiento\n"
        response += "‚Ä¢ Fortaleza particular en [aspecto espec√≠fico]\n"
        response += "‚Ä¢ Oportunidad de mejora en [√°rea espec√≠fica]\n"
        response += "‚Ä¢ Correlaci√≥n interesante entre [m√©trica A] y [m√©trica B]\n\n"
        
        response += "üí° **Aplicaci√≥n Pr√°ctica:**\n"
        response += "Estas estad√≠sticas sugieren que [conclusi√≥n accionable] para "\
                   "tus decisiones de apuestas. Recomiendo considerar [estrategia espec√≠fica].\n\n"
        
        response += "¬øNecesitas que profundice en alguna m√©trica espec√≠fica o prefieres el an√°lisis de otro aspecto? üìù"

        return response
    
    def _generate_resolutive_general_response(self, entities, query):
        """Genera una respuesta resolutiva para consultas generales"""
        response = "üèÜ **INFORMACI√ìN DEPORTIVA COMPLETA**\n\n"
        
        response += f"**Consulta:** {query}\n\n"
        
        response += "üìã **Contexto General:**\n"
        response += "Bas√°ndome en tu consulta, aqu√≠ tienes informaci√≥n completa y relevante:\n\n"
        
        if entities.get("teams"):
            teams = ", ".join(entities["teams"])
            response += f"**Equipos/Jugadores:** {teams}\n"
            response += "‚Ä¢ Historial y logros relevantes\n"
            response += "‚Ä¢ Situaci√≥n actual en competiciones\n"
            response += "‚Ä¢ Pr√≥ximos desaf√≠os y partidos\n\n"
        
        if entities.get("tournaments"):
            tournaments = ", ".join(entities["tournaments"])
            response += f"**Torneos/Competiciones:** {tournaments}\n"
            response += "‚Ä¢ Formato y estructura de la competici√≥n\n"
            response += "‚Ä¢ Equipos participantes y favoritos\n"
            response += "‚Ä¢ Fechas clave y calendario\n\n"
        
        response += "üíé **Valor A√±adido:**\n"
        response += "‚Ä¢ **Factores Clave a Considerar:** [Aspectos importantes]\n"
        response += "‚Ä¢ **Oportunidades Destacadas:** [√Åreas de inter√©s]\n"
        response += "‚Ä¢ **Perspectiva Experta:** [An√°lisis profesional]\n\n"
        
        response += "üéØ **Recomendaci√≥n Accionable:**\n"
        response += "Basado en esta informaci√≥n, te recomiendo [acci√≥n espec√≠fica] "\
                   "para maximizar tus oportunidades en apuestas relacionadas.\n\n"
        
        response += "‚ö†Ô∏è **Recordatorio Importante:**\n"
        response += "‚Ä¢ Las apuestas deben ser siempre responsables\n"
        response += "‚Ä¢ Investiga m√∫ltiples fuentes antes de decidir\n"
        response += "‚Ä¢ Establece l√≠mites claros de bankroll\n\n"
        
        response += "¬øEn qu√© otro aspecto te puedo ayudar o necesitas m√°s detalles sobre algo espec√≠fico? ü§î"

        return response
    
    def _generate_non_sports_response(self, query):
        """Genera una respuesta educada para consultas no deportivas"""
        return "¬°Hola! üëã Soy un asistente especializado exclusivamente en deportes y apuestas deportivas. üèÜ\n\n" \
               "Puedo ayudarte con:\n" \
               "‚Ä¢ An√°lisis de partidos y equipos üèÄ‚öΩ\n" \
               "‚Ä¢ Recomendaciones de apuestas informadas üí∞\n" \
               "‚Ä¢ Estad√≠sticas deportivas üìä\n" \
               "‚Ä¢ Informaci√≥n sobre torneos y competiciones üèÖ\n\n" \
               "¬øEn qu√© puedo ayudarte respecto a deportes o apuestas deportivas? üòä"
    
    def _generate_error_response(self):
        """Genera una respuesta para errores del sistema"""
        return "¬°Vaya! üîß Estoy teniendo dificultades t√©cnicas moment√°neas, pero quiero ayudarte. \n\n" \
               "Mientras resuelvo esto, te puedo orientar sobre:\n" \
               "‚Ä¢ Estrategias generales de apuestas deportivas üéØ\n" \
               "‚Ä¢ An√°lisis de equipos y torneos populares üìà\n" \
               "‚Ä¢ Conceptos clave de apuestas deportivas üí°\n\n" \
               "¬øSobre qu√© deporte o tipo de apuesta te gustar√≠a conversar? üòä"
    
    def _update_context(self, session_id, entities, relevant_data):
        if "teams" in entities and entities["teams"]:
            self.context_manager.update_context(session_id, "last_mentioned_teams", entities["teams"])
        
        if "tournaments" in entities and entities["tournaments"]:
            self.context_manager.update_context(session_id, "last_mentioned_tournament", entities["tournaments"][0])
        
        if "bet_types" in entities and entities["bet_types"]:
            self.context_manager.update_context(session_id, "preferred_bet_types", entities["bet_types"])
    
    async def is_connected(self):
        return await self.api_client.is_connected()